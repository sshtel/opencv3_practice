#include <opencv2/opencv.hpp>
#include <opencv2/highgui.hpp>

#include "common_directory.hpp"

#include <device_ocl.h>
#include <auto_etr.h>


#ifdef WIN32

#include <windows.h>
#include <process.h>
#include <stdlib.h>
#endif

#define IMAGE_ROOT "..\\..\\..\\images"
#define HOG_IMG IMAGE_ROOT"\\hog_1.jpg"
#define HOG_VID IMAGE_ROOT"\\pedestrian.mp4"

#define HOG_VID_01 IMAGE_ROOT"\\pedestrian\\pedestrian01.mp4"
#define HOG_VID_02 IMAGE_ROOT"\\pedestrian\\pedestrian02.mp4"
#define HOG_VID_03 IMAGE_ROOT"\\pedestrian\\pedestrian03.mp4"
#define HOG_VID_04 IMAGE_ROOT"\\pedestrian\\pedestrian04.mp4"
#define HOG_VID_05 IMAGE_ROOT"\\pedestrian\\pedestrian05.mp4"
#define HOG_VID_06 IMAGE_ROOT"\\pedestrian\\pedestrian06.mp4"
#define HOG_VID_07 IMAGE_ROOT"\\pedestrian\\pedestrian07.mp4"
#define HOG_VID_08 IMAGE_ROOT"\\pedestrian\\pedestrian08.mp4"



void mog2_sample1()
{

	//global variables  
	cv::Mat frame; //current frame  
	cv::Mat resizeF;
	cv::Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method  
	cv::Mat noShadow;
	cv::Mat morphKernel;
	
	morphKernel = cv::Mat(5, 5, CV_8U);

	cv::Ptr< cv::BackgroundSubtractor> pMOG2; //MOG2 Background subtractor  

	pMOG2 = cv::createBackgroundSubtractorMOG2();

	cv::VideoCapture vc;
	{
		vc.open(3);
		if (!vc.isOpened())
			throw runtime_error(string("can't open video file: "));
		vc >> frame;
	}

	int resize_rows = frame.rows / 1;
	int resize_cols = frame.cols / 1;

	cv::Mat element = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3), cv::Point(1, 1));
	noShadow = cv::Mat(cv::Size(resize_cols, resize_rows), CV_8U);



	//unconditional loop     
	while (true) {
		cv::Mat cameraFrame;
		vc >> frame;
		resize(frame, resizeF, cv::Size(resize_cols, resize_rows));

		//cv::GaussianBlur(resizeF, resizeF, cv::Size(3, 3), 0, 0, cv::BORDER_DEFAULT);

		pMOG2->apply(resizeF, fgMaskMOG2);

		//shadow.zeros(cv::Size(resize_cols, resize_rows), CV_8U);
		int white = 0, gray = 0;
		for (int y = 0; y < resize_rows; ++y){
			for (int x = 0; x < resize_cols; ++x){
				noShadow.at<uchar>(y, x) = 0;
				uchar value = fgMaskMOG2.at<uchar>(y, x);
				if (value >= 255) {
					white++;
					noShadow.at<uchar>(y, x) = 255;
				}
				else if (value >= 100) {
					gray++;
				}

			}
		}
		
		std::cout << "white : " << white << " gray : " << gray << std::endl;

		cv::morphologyEx(noShadow, noShadow, cv::MORPH_OPEN, morphKernel);
		cv::morphologyEx(noShadow, noShadow, cv::MORPH_OPEN, morphKernel);
		
		imshow("Origin", resizeF);
		imshow("MOG2", fgMaskMOG2);
		imshow("no shadow", noShadow);
		
		if (cv::waitKey(30) >= 0)
			break;
	}

}




void mog2_and_knn()
{

	//global variables  
	cv::Mat frame; //current frame  
	cv::Mat resizeF;
	cv::Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method  
	cv::Mat fgMaskKNN; //fg mask fg mask generated by MOG2 method  


	cv::Ptr< cv::BackgroundSubtractor> pKNN; //MOG Background subtractor  
	cv::Ptr< cv::BackgroundSubtractor> pMOG2; //MOG2 Background subtractor  

	pKNN = cv::createBackgroundSubtractorKNN();
	pMOG2 = cv::createBackgroundSubtractorMOG2();

	char fileName[200] = HOG_VID_03; //Gate1_175_p1.avi"; //mm2.avi"; //";//_p1.avi";  

	cv::VideoCapture vc;
	{
		vc.open(fileName);
		if (!vc.isOpened())
			throw runtime_error(string("can't open video file: "));
		vc >> frame;
	}

	cv::Mat element = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3), cv::Point(1, 1));

	//unconditional loop     
	while (true) {
		cv::Mat cameraFrame;
		vc >> frame;

		resize(frame, resizeF, cv::Size(frame.size().width / 2, frame.size().height / 2));
		pMOG2->apply(resizeF, fgMaskMOG2);
		pKNN->apply(resizeF, fgMaskKNN);
		
		imshow("Origin", resizeF);
		imshow("MOG2", fgMaskMOG2);
		imshow("KNN", fgMaskKNN);

		if (cv::waitKey(30) >= 0)
			break;
	}

}


void camera_work()
{

	//global variables  
	cv::Mat frame; //current frame  
	cv::Mat resizeF;
	cv::Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method  
	cv::Mat fgMaskKNN; //fg mask fg mask generated by MOG2 method  


	cv::Ptr< cv::BackgroundSubtractor> pKNN; //MOG Background subtractor  
	cv::Ptr< cv::BackgroundSubtractor> pMOG2; //MOG2 Background subtractor  

	pKNN = cv::createBackgroundSubtractorKNN();
	pMOG2 = cv::createBackgroundSubtractorMOG2();

	

	cv::VideoCapture vc;
	{
		vc.open(0);
		if (!vc.isOpened())
			throw runtime_error(string("can't open video file: "));
		vc >> frame;
	}

	cv::Mat element = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3), cv::Point(1, 1));

	//unconditional loop     
	while (true) {
		cv::Mat cameraFrame;
		vc >> frame;

		resize(frame, resizeF, cv::Size(frame.size().width / 2, frame.size().height / 2));
		pMOG2->apply(resizeF, fgMaskMOG2);
		pKNN->apply(resizeF, fgMaskKNN);


		imshow("Origin", resizeF);
		imshow("MOG2", fgMaskMOG2);
		imshow("KNN", fgMaskKNN);

		if (cv::waitKey(30) >= 0)
			break;
	}

}

int main(int argc, char *argv[])
{
	mog2_sample1();
	//mog2_and_knn();
	//camera_work();
	return 0;
}
